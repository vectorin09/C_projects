#include <iostream>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <cstdlib>
#include <iomanip>
#include <sstream>

using namespace std;

// ==================== CLASS DEFINITIONS ====================

class st
{
public:
    int book_id;
    string book_name;
    string author_name;  // ADDED: Author name field
    st* left;
    st* right;
    int book_count;
    
    // Constructor to initialize members
    st() : book_id(0), book_name(""), author_name(""), left(NULL), right(NULL), book_count(0) {}
};

typedef struct user
{
    int book_id;
    int user_id;
    char* user_name;
    char* book_name;
    int issue_date;
    int due_date;
    user* left;
    user* right;
    
    // Constructor
    user() : book_id(0), user_id(0), user_name(NULL), book_name(NULL), 
             issue_date(0), due_date(0), left(NULL), right(NULL) {}
} user;

class node_act
{
public:
    void add(const char* pre);
    void add_books(st** node, st* new_node);
    void add_issue(user** node, user* new_node);
    void print_books(st* head_ptr);
    void print_issue(user* user_head_ptr);
    st* search_node(st* head, int id, string buffer);
    user* user_search_node(user* head_ptr, int id, string buffer);
    void update_node(st* head_ptr, int id, char* book);
    void deleted_add(st* node, st* new_node);
    void delete_node(st* node, int id);
    void _return(void);
};

class ui
{
public:
    void main_ui(void);
    void mem_ui(string menu);
    void show_ui(int book_id, string book_name, string author_name = "");  // ADDED: Author parameter
    string preference();
}; 

// ==================== GLOBAL VARIABLES ====================

int buffer_node = 0;
int deletes_node = 0;
int buffer = 0;
int deletes = 0;

ui interface;
node_act cl;
node_act op;

user* user_head_ptr = NULL;
st* head_ptr = NULL;

// ==================== NODE_ACT IMPLEMENTATION ====================

void node_act::add(const char* pre)
{
    if(strcmp(pre, "Add New Book\0") == 0)
    {
        int buf;
        cout << "Enter the No of books: ";
        cin >> buf;
        
        for(int i = 0; i < buf; i++)
        {
            st* temp = new st();
            cout << "  Enter the book id: ";
            cin >> temp->book_id;
            cin.ignore();  // Clear newline from buffer
            cout << "  Enter the book name: ";
            getline(cin, temp->book_name);
            cout << "  Enter the author name: ";  // ADDED: Author input
            getline(cin, temp->author_name);
            temp->left = NULL;
            temp->right = NULL;
            temp->book_count = 1;  // FIXED: Initialize to 1
            add_books(&head_ptr, temp);
            cout << "Book count: " << temp->book_count << endl;
        }
    }
    else if(strcmp(pre, "Issue Book\0") == 0)  // FIXED: Typo corrected
    {
        user* temp = new user();  // FIXED: Use new instead of malloc
        cout << "  Enter the book_id: ";
        cin >> temp->book_id;
        cout << "  Enter the user_id: ";
        cin >> temp->user_id;
        cout << "  Enter issue_date: ";
        cin >> temp->issue_date;
        temp->due_date = temp->issue_date + 7;
        add_issue(&user_head_ptr, temp);
    }
}

void node_act::add_books(st** node, st* new_node)
{
    // FIXED: Removed incorrect wait() call
    
    if(deletes_node != 0)
    {
        deleted_add(*node, new_node);
        deletes_node--;
        return;
    }
    
    if(*node == NULL)
    {
        *node = new_node;
        return;
    }
    else if(((*node)->book_id) > (new_node->book_id))
    {
        add_books(&((*node)->right), new_node);
    }
    else
    {
        add_books(&((*node)->left), new_node);    
    }
}

void node_act::add_issue(user** node, user* new_node)
{
    if(*node == NULL)
    {
        *node = new_node;
        return;
    }
    else if(((*node)->book_id) > (new_node->book_id))
    {
        add_issue(&((*node)->right), new_node);
    }
    else
    {
        add_issue(&((*node)->left), new_node);
    }
}

void node_act::print_books(st* head_ptr)
{
    if(head_ptr != NULL)
    {
        cout << " " << endl;
        interface.show_ui(head_ptr->book_id, head_ptr->book_name, head_ptr->author_name);
        print_books(head_ptr->left);
        print_books(head_ptr->right);
    }
    else
    {
        return;
    }
}

void node_act::print_issue(user* user_head_ptr)
{
    if(user_head_ptr != NULL)
    {
        if(user_head_ptr->book_name != NULL)  // FIXED: NULL check
            interface.show_ui(user_head_ptr->book_id, user_head_ptr->book_name);
        else
            interface.show_ui(user_head_ptr->book_id, "Unknown");
            
        print_issue(user_head_ptr->left);
        print_issue(user_head_ptr->right);
    }
    else
    {
        return;
    }
}

// FIXED: Search function now properly searches both left and right
st* node_act::search_node(st* head_ptr, int id, string buffer)
{
    if(head_ptr == NULL)
        return NULL;
        
    if(head_ptr->book_id == id || head_ptr->book_name == buffer)
    {
        return head_ptr;
    }
    
    // Search left subtree
    st* left_result = search_node(head_ptr->left, id, buffer);
    if(left_result != NULL)
        return left_result;
    
    // Search right subtree
    return search_node(head_ptr->right, id, buffer);
}

user* node_act::user_search_node(user* head_ptr, int id, string buffer)
{
    if(head_ptr == NULL)
        return NULL;
        
    if(head_ptr->book_id == id || 
       (head_ptr->book_name != NULL && string(head_ptr->book_name) == buffer))
    {
        return head_ptr;
    }
    
    // Search left subtree
    user* left_result = user_search_node(head_ptr->left, id, buffer);
    if(left_result != NULL)
        return left_result;
    
    // Search right subtree
    return user_search_node(head_ptr->right, id, buffer);
}

void node_act::update_node(st* head_ptr, int id, char* book)
{
    if(head_ptr == NULL)
        return;
        
    if(head_ptr->book_id == id)
    {
        head_ptr->book_id = 999;
        cout << head_ptr->book_id << endl;
        return;
    }
    
    update_node(head_ptr->left, id, book);
    update_node(head_ptr->right, id, book);
}

void node_act::deleted_add(st* node, st* new_node)
{
    if(node == NULL)
    {
        return;
    }
    
    if(node->book_id == 9999)
    {
        node->book_id = new_node->book_id;
        node->book_name = new_node->book_name;
        return;
    }
    
    deleted_add(node->left, new_node);
    deleted_add(node->right, new_node);
}

void node_act::delete_node(st* node, int id)
{
    if(node == NULL)
        return;
        
    if(node->book_id == id)
    {
        node->book_id = 9999;
        node->book_name = " ";
        deletes_node++;
        return;
    }
    
    delete_node(node->left, id);
    delete_node(node->right, id);
}

void node_act::_return(void)
{
    int data, today_date;
    cout << "Enter the book_id which you want to return: ";
    cin >> data;
    
    st* temp = search_node(head_ptr, data, " ");
    
    // FIXED: Added NULL check
    if(temp == NULL)
    {
        cout << "Book not found in library!" << endl;
        return;
    }
    
    temp->book_count++;  // FIXED: Proper increment
    
    user* temp1 = user_search_node(user_head_ptr, data, "");
    if(temp1 == NULL)
    {
        cout << "The details not found on issued list" << endl;
        return;
    }
    
    cout << "Enter the today date: ";
    cin >> today_date;
    
    if(today_date > (temp1->due_date))
    {
        cout << "You have to pay a fine Rs." 
             << ((today_date) - (temp1->due_date)) * 20 << endl;
    }
    else 
    {
        cout << "You are free to leave" << endl;
    }
}

// ==================== UI IMPLEMENTATION ====================

void ui::main_ui(void)
{
    cout << "-----------------------------------------------------" << endl;
    cout << "|                   LIBRARY HOME PAGE               |" << endl;
    cout << "-----------------------------------------------------" << endl;    
    cout << "|1.Add New Book                                     |" << endl;
    cout << "|2.Update Book Details                             |" << endl;  // FIXED: Capitalization
    cout << "|3.Remove Book                                      |" << endl;
    cout << "|4.Search Book                                      |" << endl;
    cout << "|5.View All Books                                   |" << endl;
    cout << "|6.Issue Book                                       |" << endl;  // FIXED: Typo
    cout << "|7.Return Book                                      |" << endl;
    cout << "|8.List Issued Books                                |" << endl;
    cout << "|9.Save                                             |" << endl;
    cout << "|10.Exit                                            |" << endl;
    cout << "-----------------------------------------------------" << endl;
    
    string _65 = preference();
    
    if((_65 != "Add New Book") && (_65 != "Update Book Details") && 
       (_65 != "Issue Book") && (_65 != "View All Books"))
    {
        mem_ui(_65);
    }
    else if(_65 == "View All Books")
    {
        op.print_books(head_ptr);
    }    
    else 
    {
        op.add(_65.c_str());
    }
}

void ui::mem_ui(string menu)
{
    cout << " " << endl;
    cout << "----------------------------------------------------" << endl;
    cout << menu << endl;
    cout << "----------------------------------------------------" << endl;
    cout << "|A. By Book ID                                      |" << endl;
    cout << "|B. By Book Name                                    |" << endl;
    cout << "|C. By Author Name                                  |" << endl;
    cout << "|D. Back to Main Menu                               |" << endl; 
    cout << "+---------------------------------------------------+" << endl;
}

void ui::show_ui(int book_id, string book_name, string author_name)
{
    cout << "-------------------------------------------------------------" << endl;
    int width = 60;
    
    // FIXED: Properly convert int to string and concatenate with author
    stringstream ss;
    if(author_name.empty())
        ss << book_id << " | " << book_name;
    else
        ss << book_id << " | " << book_name << " | " << author_name;
    string content = ss.str();
    
    int padding = width - 2 - content.size();
    if(padding < 0) padding = 0;
    
    cout << "|" << content << string(padding, ' ') << "|" << endl;
    cout << "-------------------------------------------------------------" << endl;
}

string ui::preference()
{
    cout << "  Enter the choice: ";
    cin >> buffer;
    
    char array[][20] = {
        "Add New Book", 
        "Update Book Details",  // FIXED: Capitalization
        "Remove Book", 
        "Search Book", 
        "View All Books", 
        "Issue Book",  // FIXED: Typo
        "Return Book", 
        "List Issued Books", 
        "Save", 
        "Exit"
    };
    
    if(buffer >= 10) 
    {
        exit(0);  // FIXED: Use exit instead of _Exit
    }
    else
    {
        return array[buffer - 1];
    }
}

// ==================== MAIN FUNCTION ====================

int main()
{
    if((fork() == 0))
    {
        // Child process - Load data from files
        
        // Load books
        FILE* fp = fopen("database_book.txt", "r");
        if(fp == NULL)
        {
            cout << "Book database file not found! Starting with empty library." << endl;
            exit(0);
        }
        
        int book_id;
        char book_name[100];
        char author_name[100];  // ADDED: Author field
        int book_count;
        
        while(fscanf(fp, "%d %s %s %d", &book_id, book_name, author_name, &book_count) == 4)
        {
            st* temp = new st();
            temp->book_id = book_id;
            temp->book_name = book_name;
            temp->author_name = author_name;  // ADDED: Set author name
            temp->book_count = book_count;
            temp->left = NULL;
            temp->right = NULL;
            cl.add_books(&head_ptr, temp);
        }
        fclose(fp);
        
        // Load issued books
        FILE* fp1 = fopen("database_issue.txt", "r");
        if(fp1 == NULL)  // FIXED: Check fp1 instead of fp
        {
            cout << "Issue database file not found! Starting with no issued books." << endl;
            exit(0);
        }
        
        int user_id;
        char user_name[100];
        char issued_book_name[100];
        int issue_date;
        int due_date;
        
        while(fscanf(fp1, "%d %d %s %s %d %d", 
                     &book_id, &user_id, user_name, 
                     issued_book_name, &issue_date, &due_date) == 6)
        {
            user* temp = new user();
            temp->book_id = book_id;
            temp->user_id = user_id;
            temp->user_name = new char[strlen(user_name) + 1];
            strcpy(temp->user_name, user_name);
            temp->book_name = new char[strlen(issued_book_name) + 1];
            strcpy(temp->book_name, issued_book_name);
            temp->issue_date = issue_date;
            temp->due_date = due_date;
            temp->left = NULL;
            temp->right = NULL;
            cl.add_issue(&user_head_ptr, temp);
        }
        fclose(fp1);
        
        exit(0);
    }
    else
    {
        // Parent process - Wait for child to finish loading data
        int status;
        wait(&status);
        
        // Run main UI loop
        while(1)
        {
            interface.main_ui();
        }
    }
    
    return 0;
}
